#Python基础#

在Python中，能够直接处理的数据类型有以下几种：

	对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等

	字符串是以单引号'或双引号"括起来的任意文本，如果'本身也是一个字符，那就可以用""括起来，比如"I'm OK" 'I\'m \"OK\"!' - I'm "OK"!
	如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r''表示''内部的字符串默认不转义
	如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用'''...'''的格式表示多行内容

	在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来

	空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。

变量

	变量名必须是大小写英文、数字和_的组合，且不能用数字开头

	这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错

	理解变量在计算机内存中的表示也非常重要。当我们写：a = 'ABC'
	Python解释器干了两件事情：
	1.在内存中创建了一个'ABC'的字符串；
	2.在内存中创建了一个名为a的变量，并把它指向'ABC'。
	也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据

常量

	在Python中，通常用全部大写的变量名表示常量：PI = 3.14159265359
	但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变

整数的除法为什么也是精确的

	10 / 3  3.3333333333333335 /除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数 9 / 3 3.0
	还有一种除法是//，称为地板除，两个整数的除法仍然是整数 10 // 3 3
	因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：10 % 3 1

Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。

---
字符编码
	
	全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。

	Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了

	你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。

	如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。

	本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：
	A	01000001	00000000 01000001	01000001
	中	x	01001110 00101101	11100100 10111000 10101101

	UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。

	可以总结一下现在计算机系统通用的字符编码工作方式：

![](https://i.imgur.com/xk9Eo7K.png)

![](https://i.imgur.com/rNlFdfv.png)

	所以你看到很多网页的源码上会有类似<meta charset="UTF-8" />的信息，表示该网页正是用的UTF-8编码。

Python的字符串

	在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言

	对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符
	>>> ord('A')  65  >>> ord('中')  20013  >>> chr(66)  'B'  >>> chr(25991)  '文'
	还可以用十六进制这么写str >>> '\u4e2d\u6587'  '中文'

	由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。

	Python对bytes类型的数据用带b前缀的单引号或双引号表示：x = b'ABC'

	以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：

	>>> 'ABC'.encode('ascii')
	b'ABC'
	>>> '中文'.encode('utf-8')
	b'\xe4\xb8\xad\xe6\x96\x87'
	>>> '中文'.encode('ascii')
	Traceback (most recent call last): File "<stdin>", line 1, in <module>
	UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)
	英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。

	反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：
	>>> b'ABC'.decode('ascii')
	'ABC'
	>>> b'\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
	'中文'

	如果bytes中包含无法解码的字节，decode()方法会报错：
	>>> b'\xe4\xb8\xad\xff'.decode('utf-8')
	Traceback (most recent call last):  ...
	UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte
	如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节

	要计算str包含多少个字符，可以用len()函数：
	>>> len('ABC')
	3
	>>> len('中文')
	2
	len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：

	>>> len(b'ABC')
	3
	>>> len(b'\xe4\xb8\xad\xe6\x96\x87')
	6
	>>> len('中文'.encode('utf-8'))
	6	

	在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。

	由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：
	(#!/usr/bin/env python3)
	(# -*- coding: utf-8 -*-)

	申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码：

格式化:
		
	在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：
	>>> 'Hi, %s, you have $%d.' % ('Michael', 1000000)
	'Hi, Michael, you have $1000000.'
	
	%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略
	%f	浮点数  %x	十六进制整数
	如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：
	有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：

	另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：

	>>> 'Hello, {0}, 成绩提升了 {1:.1f}%'.format('小明', 17.125)
	'Hello, 小明, 成绩提升了 17.1%'

list

	Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。
	用len()函数可以获得list元素的个数
	用索引来访问list中每一个位置的元素，记得索引是从0开始的：
	如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：
	list是一个可变的有序表，所以，可以往list中追加元素到末尾：
	classmates = ['Michael', 'Bob', 'Tracy']
	classmates.append('Adam')
	也可以把元素插入到指定的位置，比如索引号为1的位置：
	classmates.insert(1, 'Jack')
	要删除list末尾的元素，用pop()方法：
	要删除指定位置的元素，用pop(i)方法，其中i是索引位置：
	要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：
	list里面的元素的数据类型也可以不同，比如：
	>>> L = ['Apple', 123, True]
	list元素也可以是另一个list，比如：
	>>> s = ['python', 'java', ['asp', 'php'], 'scheme']
	>>> len(s)
	4

tuple

	tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：
	classmates = ('Michael', 'Bob', 'Tracy')
	classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。
	不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。
	当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来
	如果要定义一个空的tuple，可以写成()：t = ()
	只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：t = (1,)

	最后来看一个“可变的”tuple：
	>>> t = ('a', 'b', ['A', 'B'])
	>>> t[2][0] = 'X'
	>>> t[2][1] = 'Y'
	>>> t
	('a', 'b', ['X', 'Y'])
	表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！

条件判断

	根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。

	注意不要少写了冒号:。

	if <条件判断1>:
    		<执行1>
	elif <条件判断2>:
    		<执行2>
	elif <条件判断3>:
    		<执行3>
	else:
    		<执行4>

	s = input('birth: ')
	birth = int(s)
	if birth < 2000:
    		print('00前')
	else:
    		print('00后')

循环

	Python的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来
	names = ['Michael', 'Bob', 'Tracy']
	for name in names:
    		print(name)
	所以for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。

	Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：

	第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。
	sum = 0
	n = 99
	while n > 0:
    		sum = sum + n
    		n = n - 2
		print(sum)
	在循环中，break语句可以提前退出循环。
	在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环

	不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。
	
使用dict和set
	
dict

	Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。
	假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list。
	如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。

	>>> d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
	>>> d['Michael']
	95
	dict的实现原理和查字典是一样的。
	给定一个名字，比如'Michael'，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。

	把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：
	由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：
	如果key不存在，dict就会报错：
	要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：
	'Thomas' in d
	二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：
	d.get('Thomas')
	d.get('Thomas', -1)

	要删除一个key，用pop(key)方法，对应的value也会从dict中删除：

	请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。


	和list比较，dict有以下几个特点：
	查找和插入的速度极快，不会随着key的增加而变慢；
	需要占用大量的内存，内存浪费多。

	dict的key必须是不可变对象。
	这个通过key计算位置的算法称为哈希算法（Hash）。
	要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key

set
	
	set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。

	要创建一个set，需要提供一个list作为输入集合：

	重复元素在set中自动被过滤：

	通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：

	通过remove(key)方法可以删除元素：

	set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作
	
	>>> s1 = set([1, 2, 3])
	>>> s2 = set([2, 3, 4])
	>>> s1 & s2
	{2, 3}
	>>> s1 | s2
	{1, 2, 3, 4}
	set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。

再议不可变对象

	对于可变对象，比如list，对list进行操作，list内部的内容是会变化的

	而对于不可变对象，比如str，对str进行操作
	
	>>> a = 'abc'
	>>> b = a.replace('a', 'A')
	'Abc'
	>>> a
	'abc'
	
	a是变量，而'abc'才是字符串对象！有些时候，我们经常说，对象a的内容是'abc'，但其实是指，a本身是一个变量，它指向的对象的内容才是'abc'

	当我们调用a.replace('a', 'A')时，实际上调用方法replace是作用在字符串对象'abc'上的，而这个方法虽然名字叫replace，但却没有改变字符串'abc'的内容。相反，replace方法创建了一个新字符串'Abc'并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串'abc'，但变量b却指向新字符串'Abc'了：

	所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。
	